[{"body":"","link":"https://itohi.com/about/","section":"about","tags":null,"title":"Abouts"},{"body":"2022 Migrate to Hugo Migrate backend from Python to Go Explore tinygo and embedded itohio Github organization created and repositories cloned from personal repo 2021-* Rebuilt the server Transitioned to containerized infrastructure Moved code to https://github.com/itohio repo Started working on EasyRobot framework Started working on Collective project Started working on Phingo project Up to 2021 Dismantled the server Was playing around with various messaging protocols Was playing around with various misc protocols/Wireguard 2019-04-18 Weather Station project became mature enough Weather Station submitted on Tindie ! 2018-07-10 First blogs shared on Hackaday.io ! Facebook page was created for ITOHI Signed up for Twitter Keywords updated Favicon updated 2018-07-02 Initial launch of the site First blog post ","link":"https://itohi.com/about/changelog/","section":"about","tags":null,"title":"Changelog"},{"body":"","link":"https://itohi.com/about/contact/","section":"about","tags":null,"title":"Contact"},{"body":"","link":"https://itohi.com/","section":"","tags":null,"title":"ITOHI"},{"body":"What is ITOHI? ITOHI is an acronym for Invent This Invent That Open Hardware Inventions. This page hosts various Open Source and Open Hardware projects that I have created and wish to share with the world.\nWho am I My name is Andrius and I am a software engineer with a physics degree in telecommunication and electronics. My main passion lies in the research and development of various software as well as hardware projects. Mostly those projects stay in my closet collecting dust, however, the ITOHI project strives to change that.\nI have decided to create all the projects as Open Source/Open Hardware so that the community could benefit from whatever I create or invent. In fact, the whole site source code is Open Source also! I am not planning to give it all for free, of course, mind you! Some of the projects will be growing towards a full-blown product for those who don't wish to solder anything from scratch or wish to save some time by purchasing modules or other electronic widgets that I'll put out for sale.\nUntil I reach the maturity of selling, you are free to support my inventing stuff by donating :)\nFreelancing I've been having a really interesting career as a freelancer both in hardware and software worlds. I take circuit engineering, soldering jobs as well as development primarily using ASM, C/C++, C#, Python languages for embedded platforms, or PC both Linux and Windows.\nI've been doing all kinds of projects ranging from some signal processing, various process controllers to image processing and machine learning. When I was doing my Ph.D. I was writing various math-intensive algorithms as well as scientific apparatus controlling software that is being used even today.\nI've designed both hardware and software parts of the light spectrum analyzer that was used for liquid crystal research.\nI've built autonomous robots and written navigation AI for them.\nI've designed and built massively parallel surveillance application.\nI've created a state of the art algorithm for 3D model slicing designed for 3x independent printing heads 3D Printer during my CTO career at a 3D printer company.\nDeveloped an OpenVRL engine - Opensource Virtual Reality Library for 3D simulations...\nAnd many more...\nCurrently holding a full-time position as a network automation engineer.\nAnyway, if you have any kind of interesting project, I'd gladly participate - just let me know :)\n","link":"https://itohi.com/about/me/","section":"about","tags":null,"title":"About"},{"body":"","link":"https://itohi.com/tags/arduino/","section":"tags","tags":null,"title":"arduino"},{"body":"Motivation My son has a cat. And I've become very curious about the cat's feeding and toilet habits. Mainly I'm interested in how long does it take him to go to the toilet after eating as I've noticed a pattern: At first he goes to the kitchen, eats and then runs around the house wrecking havoc for some time and then goes to the toilet. So I'm curious whether this is his usual routine and moreover how many times during the day and night does he need to use his toilet. I might even build a collar for him to track the magnitude of his movements in the future :)\nIn order to accomplish this task at first I was thinking about using RFID tags that I have plenty. But that is rather crude... Then I remembered, that I have a couple of PIR motion sensors collecting dust. So I decided to clean that dust away, and go for a more interesting approach. So the idea is this: build a smart motion sensor, that would connect to the internet once the motion is detected and post some message somewhere. I would then gather those messages along with timestamps and analyze the data in some way later. It seemed that PIR sensor and ESP-1 module had the best chance of perfect partnership.\nProgramming I decided to use MQTT broker that I have already setup on some free service, so that I could get notifications of motion events at my phone. I was using PubSubClient Arduino Library for MQTT in my other projects, but this time I decided to try MQTT Arduino Library. Although I was considering building my own library, because neither of those two support additional data passing to message callbacks. But that's a story for another time. I'm glad that I didn't go that route, because I wouldn't be able to finish this project in half a day :)\nSo, The program itself is very simple - when ESP boots up, it connects to WiFi, then to MQTT broker, publish a message to \u0026quot;motion\u0026quot; topic with payload as ESP MAC address and then go to sleep indefinitely. Basicaly the whole code looks like this:\n1\u0026lt;pre\u0026gt;the code \u0026lt;br /\u0026gt;bla \u0026lt;br /\u0026gt;bla\u0026lt;/pre\u0026gt; You can find this code in this github repository. Just keep in mind, that I'll be developing it further(Like adding web interface for configuration, OTA, etc.), thus it'll get more complicated.\nAnyway, I flashed the code to an ESP-1 module using my custom programmer and started to experiment with how to make the PIR sensor interface with the ESP. The requirement was, that the ESP would be permanently in deep sleep mode until there was motion detected.\nAt first I tried to build a simple circuit consisting of NPN transistor, a couple of resistors and a capacitor to trigger RST pin of the ESP, but that was very unreliable, and, honestly, ugly. After several variants of the trigger circuit I came up with the following idea: What if the ESP is disabled altogether until the motion is detected ?\nAfter first try it appeared to be working really well! Basically what I did, was connecting RST and EN pins together on the ESP, and connect those pins to the OUT of the PIR sensor. Also I've connected GPIO0 to VCC for good measure. Then I adjusted the ON time on the PIR sensor to about 10-20 seconds, since the ESP need at most 5 seconds to connect to WiFi and send MQTT message. That works, because normally the output of the PIR sensor is low, and it goes high when it detects motion. This high signal is enough to enable and boot the ESP chip. The signal should be high long enough for the ESP to finish publishing the message to MQTT. Luckily the PIR motion sensor I have has a potentiometer that allows to configure not only sensitivity, but the trigger timeout.\nI desoldered the header pins from ESP-1 module so it would take much less space. Then the PIR sensor had to be modified a little bit. As you may know, the PIR sensor board has an inbuilt voltage regulator. That had to go, but I didn't want to mess with the board itself. Therefore what I did was solder a little jumper over a reverse protection diode and the regulator like so:\nAnd that is basically it! Just connect a LiPo or LiIon battery and the Smart PIR sensor is ready! I've built three of these - two for the cat, and one for my roommate to check how often she goes to the balcony for a smoke despite a prominent NO SMOKING sign on the door :)\nAdditionally I wrapped the boards in shrink tubes cutting out windows for the pins and the sensor lens, stuck some double-sided tape and places the sensors at strategic locations :)\n","link":"https://itohi.com/blog/esp-1-smart-motion-sensor-using-pir-and-mqtt/","section":"blog","tags":["arduino","atom","esp8266","IoT","Sensors"],"title":"Arduino ESP8266 Smart Motion Sensor using PIR and MQTT"},{"body":"","link":"https://itohi.com/tags/atom/","section":"tags","tags":null,"title":"atom"},{"body":"","link":"https://itohi.com/blog/","section":"blog","tags":null,"title":"Blogs"},{"body":"","link":"https://itohi.com/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://itohi.com/tags/esp8266/","section":"tags","tags":null,"title":"esp8266"},{"body":"","link":"https://itohi.com/categories/iot/","section":"categories","tags":null,"title":"iot"},{"body":"","link":"https://itohi.com/tags/iot/","section":"tags","tags":null,"title":"IoT"},{"body":"","link":"https://itohi.com/tags/sensors/","section":"tags","tags":null,"title":"Sensors"},{"body":"","link":"https://itohi.com/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"In a previous post I've described how to build a Weather Station based on ESP8266 chip and various breakout boards you can buy e.g. on Aliexpress. In this post, however I'll share with you how I built a standalone PCB boards containing all the required components. To recap - this is a ESP8266 based Weather Station, that measures surrounding air temperature, humidity, pressure along with light and battery voltage. Connects to an MQTT broker and reports it's data there. There are three variants: bare board with no display, which can be connected to a lipo battery, solar panel and sit somewhere with plenty of sunlight for ages, or it can have either an ePaper display or 0.96\u0026quot; OLED display and sit on your desk.\nMy main motivation for this project was to build a network of sensors scattered around my house and city so that I could monitor the weather myself. One of the use cases involved a two room biology museum where people were concerned about air temperature and humidity, where I used two headless boards enclosed in 3D printed case and simple python MQTT client to gather all the data in a spreadsheet for further analysis.\nOpenSCAD models for the cases as well as the firmware code are in the git repository.\nDesigning circuit board I decided to have three variants of the Weather Station: headless, with OLED or ePaper displays. Headless can be flashed into OLED or ePaper board. All the designs were done using EasyEDA software, all the parts and PCBs were ordered using their services.\nScematics The schematics contains all the support components for ESP8266, LiPo/LiIon battery charger based on TP4056. Everything is being powered by low drop out voltage regulator RT9013-33GB. BME280 is connected to pins that usually serve as a Serial port. However in order to fit ePaper I run out of pins. The sensor doesn't mind the initial bootup messages, that ESP spills into that port. Light sensor and measurement of battery voltage is implemented using MAX4544EUA+T analog switch. Battery voltage is read out using R5/R6 voltage divider and light sensor using R7 and R8. GPIO5 is used for changing sensitivity. Basically there are two ranges for the light sensor due to limited ADC resolution and high dynamic range of the photo resistor used as a light sensor. So when there is little light GPIO5 is in High Z state(configured as input), and if there is a lot of light detected by the photo resistor, GPIO5 pin is driven LOW, so that R7 and R8 are connected in parallel.\nPCB I tried to make the boards as small as possible keeping in mind ESP PCB antenna requirements and trying to minimize ESP heat influence on the BME sensor. Thus I made some cutouts on the pcb board and made as long traces to the chip as possible. I ordered the PCBs along with stencils from JLCPCB and soldered them using my ESPReflow project which I will disclose later some time :)\nHeadless/OLED You can run this board without an OLED. And if you wish to connect one, make sure your OLED screen has the following pinout:\nSome variants on the market have VCC and GND pins reversed. On some boards I have missed pin descriptions for the OLED pins. Here they are (from top to bottom. square pad is VCC):\nRST GPIO0 TXD (SDA) RXD (SCL) GND VCC ePaper This board includes connectors for both OLED and ePaper, which is WaveShare 2.13\u0026quot; ePaper HAT. The firmware assumes a RED+BLACK+WHITE variant. Like this: One feature that ePaper variant has is the ability to listen for other stations and display them all on the screen. Also it is a really low power solution that lasts for a couple of months on a single 600mAh battery :)\nBuilding the firmware For development I use Atom IDE with installed PlatformIO. If you don't have this setup, then you can refer to a post where I describe how to install Atom and PlatformIO.\nFirst you need to obtain the latest sources:\n1git clone https://github.com/itohio/ESPWeather Then open ESPWeather project with Atom to build it. Alternatively, if you wish to work on the code and add features yourself, feel free to fork the repo and use it instead of the original one. Before building it, you should copy sample_wificonfig.h file into wificonfig.h and edit WIFI as well as MQTT config values:\n1// Setup Wifi networks 2#define WIFI_SSID \u0026#34;*ssid*\u0026#34; 3#define WIFI_PASSWORD \u0026#34;*passwd*\u0026#34; 4#define MQTT_ID \u0026#34;*mqtt-user*\u0026#34; 5#define MQTT_PASSW \u0026#34;*mqtt-passw*\u0026#34; 6#define MQTT_PORT *16769* 7#define MQTT_URL \u0026#34;*m23.cloudmqtt.com*\u0026#34; Second thing is to define proper variant defines which should be done in platformio.ini file. There you can find already predefined variants. You can either use one of them, or create your own. If you are using OTA, then you are gonna need to set proper ip address. Otherwise if you are flashing using USB to Serial converter platformio may detect the COM port for you. Just comment out upload_port variable. You have two options on how to upload the firmware to your board: Either use OTA or connect GND/RX/TX/RST pins to the board using your favorite ESP8266 programmer. Note that your programmer(or USB to Serial converter) must be set to use 3.3V signals, otherwise you may kill the board.\nNote about PUYA Some ESP-12 modules have a weird flash chip which causes errors with writing data to SPIFFS partition. That means, that you can flash SPIFFS data, you can read it in the code, but if you try to write to any file on that partition - the whole partition will be corrupted. This is known as PUYA issue. If you happen to have the ESP-12 with this troublesome flash chip, you should set build_flags = -D define PUYA_ISSUE in the platformio.ini file for the variant you are building.\nUnfortunately until PUYA issue is fixed in the ESP firmware, SPIFFS will not be available and in turn UI interface is useless since you cannot save any configs to the SPIFFS partition.\nUpload using OTA You can flash the board using OTA if it is connected to your WIFI network and you know it's IP address. Simply put it into platformio.ini file, power-cycle the board and click upload. OTA flashing is only available after the power-cycle, since it will stay awake for at least 1 minute before going to sleep and normal operation. Note: Keep track of the firmware size. The firmware size must be below half of the free flash memory(not used by SPIFFS), since the bootloader has to keep two versions of the firmware at the same time during flashing.\nUpload using a programmer I have built a simple programmer along with an OLED display to develop the firmware and flash production firmware. It is basically based on a Weemos development board with ESP-12 module desoldered and attached to a breadboard with headers and OLED display using some jumper cables like so: I simply stick the ESPWeather board onto the pins and click \u0026quot;Upload\u0026quot; in Atom IDE :) You can use a different setup, just that I find this quite comfortable to work on my boards before I solder OLED screens. Previously I was using POGO pins and connected them directly to the soldered ESP-12 module which I find not only uncomfortable, but also unreliable. In the future I am planning on designing a programming rig using 3D printed parts and specifically designed programmer for that purpose. Just note, that for programming GPIO0 pin should be low. You may need to power cycle the device and/or reset it a couple of times to be able to flash it.\nSetting up configuration using Web interface By default I flash the boards with UI enabled. When you first power up the board, ESP will go into AP mode with AP Name \u0026quot;ESPWeather\u0026quot;. You can connect to this AP and connect to 192.168.4.1 IP address. There you will be greeted with a welcome message and a configuration form, where you can input Host Name for the Weather Station(it will be used as AP name once you power it up again), WIFI connection details and MQTT details. You will also be able to see telemetry data in real time. UI will only be activated after a power cycle, meaning every time you power up the board, and the board will go into deep sleep after 5 minutes if no connection to the web server was made. This mode will not activate after the board wakes up from deep sleep, so you don't need to worry about somebody connecting to your Weather Station and changing/retrieving any settings. Note: UI interface is only available if you build your firmware with ESP_WEATHER_VARIANT_UI defined.\nLinks Schematics: Easyeda Project Sources: Github Tindie: Store ","link":"https://itohi.com/blog/building-esp8266-weather-station-part-ii/","section":"blog","tags":["arduino","esp8266","IoT","Sensors"],"title":"Building ESP8266 Weather station with BME280 (part 2)"},{"body":"There are a lot of forests in Lithuania which I like exploring on my bike. In the past a lot of Lithuanian resistance troops resided in those forests, so there is a big probability to stumble upon a stash of some kind. However that stash might as well be a grenade or a bomb of some kind, but nevertheless I always wanted to combine my motorcycle riding through the woods with treasure hunting and some time ago I decided to build a simple metal detector. Granted there are lots of metal detector designs, like BFO, VLFD, PI and so on (I'll briefly cover some of them in the theory section). Some of them I've tried in the past with various results and then during one boring evening of browsing the internet I stumbled upon this blog and decided to build this type of metal detector. The design is really simple - there is a simple oscillator circuit and a frequency counter. When the coil passes over or near various ferromagnetic or paramagnetic materials the frequency of the oscillator changes and based on this change you can decide where to dig. Moreover since the frequency counter can be implemented on any microcontroller you can analyse the frequency change in many different ways potentially enabling metal differentiation and even filter out frequency drift, that plagues other types of detectors.\nThe code for this project can be found here in the folder arduino/MetalDetector. Folder arduino/MetalDetector/third-party contains the code that inspired this project.\nAlong with the Arduino source code you will find there OpenSCAD files and STL files of the 3D printed parts for this project except for the screw, that holds arm and coil parts.\nMetal detector types BFO Beat Frequency Oscillator is the most simple and easy to build and operate metal detector. It consists of two oscillators running at the same frequency and the main coil of one of the oscillators is exposed, i.e. being the search coil. When there is no metal object near the coil, two oscillators are tuned to be of the same frequency. The signals from these oscillators are summed together and they generally either cancel out or produce a single tone, which is filtered out. This tone is of higher frequency than the human can hear or the headphones can reproduce, so this silence is regarded as \u0026quot;no object\u0026quot;. However when a metal object is introduced near the search coil, the oscillator resonance frequency changes and consequently after being mixed with the fixed frequency oscillator starts to give off non-zero frequency which can be heard. And depending on the pitch of that tone one can gauge how close or how big the metal object is. It is fair to note, that not only metal can induce said tone. Anything, that changes either capacitance or inductance of the oscillator resonant circuit will change the resulting pitch of the tone. So if one wishes to build such a metal detector must properly isolate the coil and the two oscillators from environment in such a way, that only search coil inductance would be affected.\nBy the way, also the two oscillators must be built in a very similar way using very similar devices (transistors) in order to eliminate temperature drift as much as possible.\nVLFD Very Low-Frequency Detector is quite popular type of metal detectors. It consists of two electrically tuned coils, usually arranged in D shapes forming a circle. One coil acts as a transmitter, while another as a receiver. Metal object introduced in the alternating induced magnetic field changes the phase of the received signal. Depending on the received signal phase depth and roughly type of metal can be determined. Also frequency of the transmitted signal can be changed which adds another dimension to the phase response analysis.\nPI Pulse Induction is another way to measure presence of metallic objects near search coil. The operation is as follows: transmitting coil is being pulsed with short pulses of current. That in turn induces pulsed magnetic field around the coil. Presence of any metallic objects changes the shape and dynamics of this pulsed electromagnetic field as in the previous examples, however in this case during current off stage of the pulse back-emf of the coil is being measured. Or more precisely the time it takes for the induced magnetic field to collapse.\nMagnetostriction based metal detectors This type of metal detection is rather complicated and involves a very interesting phenomena - magnetostriction. In simple words, when a metallic object is placed in alternating magnetic field it starts to vibrate. Conversely if a metallic object is placed inside a constant magnetic field and is being vibrated (e.g. by ultrasound) it starts to generate alternating electromagnetic field (anti-shoplifting security tags rely on the same effect). Very interesting result of magnetostriction based metal detection is ability to discriminate between different materials, as every metal produces quite a different signal.\nMagnetostriction based metal detector consists of an ultrasound transducer and a receiving coil. Earth's magnetic field is used for the required constant magnetic field. Ultrasound permeates the soil, hits the metal object and induces acoustic vibration in it. Due to magnetostriction, this metal being in constant Earth's magnetic field starts to generate alternating electromagnetic field, which in turn is picked up by the receiving coil, amplified and analysed.\nThis method is fundamentally different than the other methods of detecting metals, because it does not measure in any way the magnetic permeability of the environment.\nMetal detector using an oscillator and arduino with OLED Arduino (or any other microcontroller or platform) can be used for either VLF or PI metal detector, however I wanted to build a metal detector during a single evening. And then I stumbled upon this blog, where a metal detector is being discussed which appears to be an extremely simple using not less simple principle - arduino simply measures generated signal frequency by a simple Collpits generator circuit, which is identical to the one in the blog post except that I've added an emitter follower in order to isolate the oscillator output from the wires and arduino. Without this isolation output frequency changes drastically even if you hold your hand near the arduino module :)\nOperation The search coil has integrated Collpits oscillator with a buffer circuit, which generates the signal of around 660kHz. This signal is picked up by an Arduino Pro Mini board (using Atmega168), the frequency is being measured. 32 points of the measured frequency are stored in a FIFO buffer, scaled to fit 128 pixels of the display and drawn on the 128x32 OLED display together with battery indicator.\nThe oscillator needs to warmup for some time, but that is not really necessary - because once you start swinging the search coil and it finds any metal, there will be a spike on the graph. If the frequency of the oscillator haven't settled before that - the graph will not be horizontal. Conversely once it settles - the graph will be horizontal. No calibration or zero-in is required for this kind of operation :)\nConstruction Here is the picture of the assembled metal detector using 3D printed parts:\nHere in the picture you can see the search coil wound on the 3D printed coil carcass, braided wire that connects the search coil and the Arduino, and battery holder with the arduino itself and OLED.\nThe search coil has the oscillator integrated. Oscillator is assembled from SMD components, mainly resistors, condensators and BC846 transistors. The board of the oscillator is wrapped in copper foil in order to insulate it from the environment. I don't remember how many turns there are in the coil, but something around 15-20. I think the lower number of turns, the better, as the frequency is higher and frequency change due to inductance change with metal present is bigger which makes metal detection more sensitive. Also the higher the frequency the faster is the frequency counter response. Although there is a tradeoff of the signal frequency and the sensitivity due to the condition of the soil. If the soil is mineral-rich and moist, it may be quite conductive thus blocking high frequency signals from penetrating thus limiting accuracy and sensitivity. The windings of the coil are sealed with epoxy glue.\nThis is how the insides of the detector look like:\nArduino Pro Mini and OLED are soldered to a small breadboard along with the voltage divider, push-button switch and header for the search coil. The whole thing is glued to the two 18650 Li Ion batteries, which are glued to the bottom of the enclosure. Below is the zoom-in on the Arduino Pro Mini:\nAs you can see, the OLED display is connected to the I2C interface of the Arduino, voltage divider of the battery is connected to the A0 analog pin and the signal from the search coil oscillator connected right to the digital pin 5.\nThe oscillator circuit is placed as close to the coil as possible:\nOscillator circuit:\nOscillator receives direct power from two 18650 cells connected in series, and outputs the generated signal. And here is the signal, that is received from the coil:\nThe quality of the signal is not important(clearly I haven't put much consideration into Q2 base current), as all that matters is the triggering of arduino pin, which is configured to a counter register.\n3D printed parts 3D Printed parts were designed with OpenSCAD and printed with Geeetech Rostok 301 3D printer:\nSummary The project took me more than an evening, I'd say even more than a couple of weekends to assemble and program. There were different iterations. At first I've designed a different coil with around 30 turns, completely enclosed in epoxy glue. Also I've used a NOR gate as the oscillator buffer which worked much better than a single transistor in the final version... Although the coil was rather big - about 30cm in diameter which lowered it's sensitivity for small objects. Smaller and 3D printed coil proved to be much more stable both mechanically and electrically, however due to rather strong coupling it is sensitive even to moving my hand near the wires or even near the enclosure. I tried different approaches for frequency measurement. At first tried the same code as in the original blog post. Then after the concept proved to be viable, I added the OLED screen and moved to a frequency counting library.\nI haven't yet had a chance to test it outdoors, but indoors it finds metal construction under the floor(around 15cm of concrete along with laminate). I wonder how it would perform with different soils.\nAt some time in the future I plan to design the coil and oscillator circuit board, experiment with VLF and PI detector designs.\nThere is a warning to be said, by the way. In some countries it is illegal to construct and use metal detectors, so make sure you check with your authorities before replicating this project.\n","link":"https://itohi.com/blog/metal-detector-using-frequency-counter-and-oled-display/","section":"blog","tags":["arduino","AVR","Sensors"],"title":"Arduino Metal Detector using frequency counter and OLED display"},{"body":"","link":"https://itohi.com/tags/avr/","section":"tags","tags":null,"title":"AVR"},{"body":"","link":"https://itohi.com/categories/tools/","section":"categories","tags":null,"title":"tools"},{"body":"There are many different ways to develop and deploy embedded solutions, one of the most popular ones would be Arduino IDE. But the editor is very simplistic, without handy features such as intellisense, code refactoring and many others. I've used AVR Studio, IAR, even VIM to develop code for AVR/STM microcontrollers.. But they are either designed specifically for that platform or are commercial products. And I love Open Source :)\nThere are two Open Source IDEs that I've tried: Atom and Visual Studio Code together with PlatformIO. This post is about setting up Atom with PlatformIO to develop and deploy for many different embedded platforms. It also supports other languages, such as Python, HTML, CSS, JS, etc.\nDownloading and installing First we need to download and install Atom. Installation instructions can be found on the Atom page, so I won't duplicate them here.\nHowever Atom itself is just an IDE with a lot of various extensions. We need to install Platformio packages:\nYou should definitely install other packages (e.g. git) that you would use.\nAfter all the installation and restarting of Atom we should have PlatformIO:\nHere is a list of packages that I use:\nautocomplete-clang git-plus git-log git-diff-details linter-gcc platformio-ide platformio-ide-terminal platformio-ide-debugging project-manager github language-c language-git language-html language-css language-javascript language-python language-typescript Before creating or opening any projects we should install frameworks and boards. As for libraries... I personally don't like to install libraries globally - I tend to put them into platformio.ini project file.\nConfigure Platformio This step is also very easy with Platformio package/library managers. First we need to install platforms. You can see a list of already installed platforms on my machine:\nNow you are ready to start your projects using Platformio and Atom.\n","link":"https://itohi.com/blog/developing-with-atom-ide-and-platformio/","section":"blog","tags":["atom","platformio"],"title":"Arduino Developing with Atom IDE and PlatformIO for AVR and ESP chips"},{"body":"","link":"https://itohi.com/tags/development/","section":"tags","tags":null,"title":"development"},{"body":"","link":"https://itohi.com/categories/howto/","section":"categories","tags":null,"title":"howto"},{"body":"","link":"https://itohi.com/tags/platformio/","section":"tags","tags":null,"title":"platformio"},{"body":"","link":"https://itohi.com/tags/python/","section":"tags","tags":null,"title":"Python"},{"body":"VS Code is an light but powerful editor developed by Microsoft. I have been using this editor for Python and embedded development(using PlatformIO) for a few months now.\nUsing PlatformIO with VSCode is rather simple - just install it through built in package manager and you're good to go. However python development needs a bit more work to setup properly. Especially if you want to develop Django apps with VSCode. That is what I'll be covering here in this post.\nConfigure Python virtual environment Of course you could use globally installed Python, however having independent virtual environments for each project or experiment brings a lot of benefits. For example, you can always spin a fresh virtual environment, install required modules, test if your code works as expected and release it. Or you could just copy existing virtual environment, update modules to their newest versions and then test if your project still works as expected before upgrading those modules on your production environment. Even if you only want to experiment with python, it is always a good idea to start from a new virtual environment. At least I have acquired a habit of creating a new virtual python environment every time I start a project...\nvirtualenv So, if we want to work with virtual environments, we need to install virtualenv package first. virtualenv is a tool used to create isolated Python environments. virtualenv creates a folder which contains all the necessary executables to use the packages that a Python project would need.\n1pip install virtualenv You can test your installation using this command:\n1virtualenv --version To create a virtual environment inside your current directory:\n1virtualenv my_project This will create a directory my_project inside your current directory with all the necessary executables, modules and so on using your current python installation. In case you have more than one python version installed, you can choose whatever python version you want like this:\n1virtualenv -p /path/to/your/python/executable/python2.7 my_project To activate your newly created virtual environment on Linux:\n1source my_project/bin/activate or for Windows(You have to first enable it by configuring set-executionpolicy to e.g. remotesigned):\n1my_project\\bin\\activate.ps1 This will replace environment variables in such a way, that your current python interpreter along with all the installed modules will become the ones from your virtual environment.\nvirtualenv wrapper There is a wrapper around virtualenv, that allows for much more easier management of virtual environments. This tool is called virtualenvwrappervirtualenvwrapper and virtualenvwrapper-win for Linux and Windows environments respectively. Installation is easy using pip. Usage is also very easy. In order to create a virtual environment use:\n1mkvirtualenv my_project Virtual environment will be automatically activated. When you want to exit the virtual environment:\n1deactivate If you want to select another virtual environment:\n1workon my_project_1 There are other commands and I encourage you to go to the virtualenvwrapper page and learn about them.\npipenv There is another alternative to virtualenv or virtualenvwrapper that is called pipenv which is a dependency manager for Python projects. Pipenv manages Python modules on a per-project basis. Before installing any packages pipenv creates a Pipfile, creates a virtual environment and installs the packages:\n1cd my_project\u0026lt;br /\u0026gt;pipenv install requests This will create a Pipfile which is used to track dependencies for your project, much like requirements.txt file that you populate with pip freeze.\nI personally prefer virtualenvwrapper over other options.\nConfigure VSCode for python After you have your virtual environment, you can begin configuring VSCode. First of all you need to install Python for VSCode. To do that, go to Extensions section and type \u0026quot;python\u0026quot; into search box. The very first entry reading Python will be the package we're looking for:\nYou can go to Settings-\u0026gt;Settings and start configuring python from there, but that would setup python globally for every project. I would suggest having a settings file template somewhere and edit .vscode/settings.json file every time you create a new project. That would allow having independent virtual environments for each project. When you create a project, VSCode creates .vscode directory inside your project directory and creates settings.json file there which is empty. By the way, since I'm mainly developing from Windows, all my paths will be Windows-style. You should change the paths to the ones relevant for your installation. Linux paths are a bit different, but the principle remains.\nSo, after you've got your project in VSCode, go to Settings-\u0026gt;Settings, and select Workspace Settings. You should see something like this:\nThen copy\u0026amp;paste these values on the right:\n1{ 2 \u0026#34;python.pythonPath\u0026#34;: \u0026#34;c:\\\\Users\\\\FoxIS\\\\Envs\\\\itohi\\\\Scripts\\\\python.exe\u0026#34;, // virtual environment python binary 3 \u0026#34;python.linting.pep8Enabled\u0026#34;: true, 4 \u0026#34;python.linting.pylintPath\u0026#34;: \u0026#34;c:\\\\Users\\\\FoxIS\\\\Envs\\\\itohi\\\\Scripts\\\\pylint.exe\u0026#34;, // virtual environment pylint binary 5 \u0026#34;python.linting.pylintArgs\u0026#34;: [ 6 \u0026#34;--load-plugins\u0026#34;, 7 \u0026#34;pylint_django\u0026#34; 8 ], 9 \u0026#34;python.linting.pylintEnabled\u0026#34;: true, 10 \u0026#34;editor.rulers\u0026#34;: [ 11 80, 12 120 13 ], 14 \u0026#34;launch\u0026#34;: { 15 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, 16 \u0026#34;configurations\u0026#34;: [ 17 { 18 \u0026#34;name\u0026#34;: \u0026#34;Django\u0026#34;, 19 \u0026#34;type\u0026#34;: \u0026#34;python\u0026#34;, 20 \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, 21 \u0026#34;stopOnEntry\u0026#34;: true, 22 \u0026#34;pythonPath\u0026#34;: \u0026#34;${config:python.pythonPath}\u0026#34;, 23 \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}/manage.py\u0026#34;, 24 \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceRoot}\u0026#34;, 25 \u0026#34;args\u0026#34;: [ 26 \u0026#34;runserver\u0026#34;, 27 \u0026#34;--noreload\u0026#34;, 28 \u0026#34;--nothreading\u0026#34; 29 ], 30 \u0026#34;env\u0026#34;: {}, 31 \u0026#34;envFile\u0026#34;: \u0026#34;c:\\\\Users\\\\FoxIS\\\\Envs\\\\itohi\u0026#34;, //virtualenv path, change to whatever suits your system 32 \u0026#34;debugOptions\u0026#34;: [ 33 \u0026#34;WaitOnAbnormalExit\u0026#34;, 34 \u0026#34;WaitOnNormalExit\u0026#34;, 35 \u0026#34;RedirectOutput\u0026#34;, 36 \u0026#34;DjangoDebugging\u0026#34; 37 ] 38 } 39 ] 40 } 41} Then of course change the paths to python that are valid on your machine. In order to use pep8 and pylint, install those modules on your virtualenv:\n1pip install autopep8 2pip install pylint Now you should be ready to develop Python code and run Django development server from VSCode! :)\nPS. You can enter launch configuration into a separate launch.json file instead of the workspace configuration (\u0026quot;launch\u0026quot; json key). Also it is possible to instruct VSCode to automatically create launch.json file for you with already predefined python configurations. Just go to Debug section and select cog icon and select Python: ","link":"https://itohi.com/blog/python-development-with-visual-studio-code/","section":"blog","tags":["development","Python","Visual Studio"],"title":"Python development with Visual Studio Code"},{"body":"","link":"https://itohi.com/tags/visual-studio/","section":"tags","tags":null,"title":"Visual Studio"},{"body":"Ever since I started playing around with ESP modules I wanted to measure weather conditions in multiple location at home, friends, etc. The best way to achieve that would be to build a station that gathers various environment parameters and publishes them somewhere. That is what I've done. The very first prototype was done using ESP-1 module, DHT-11 humidity sensor and BMP280 breakout board. The station publishes gathered data to a MQTT broker from where it can be further gathered and analysed.\nBasically the operation of the station is as follows: the station will try to connect to configured multiple Wifi networks and if no such were found, will try open networks. Then it will connect to MQTT broker and announce telemetry data until 30 seconds elapses. In that case it will go to deep sleep for 30 minutes and the process starts over.\nDuring development and playing around, three variants were born: OLED, E-Paper and Headless.\nThe source code for the station is here.\nFeatures mDNS OTA Connect to free wifi or one of configured networks MQTT Pub/Sub Report temperature Report relative humidity Report air pressure Report battery voltage Monitor and display several other station telemetry Headless OLED display E-Paper display Configure Wifi networks via MQTT Configure station name via MQTT Configure station names to be monitored via MQTT Persistent telemetry MQTT messages General operation Each station variant tries to connect to either open wifi or one of configured wifi networks giving priority to configured networks. After that it tries to connect to a configured MQTT broker. Once initial telemetry data is available, starts to publish telemetry data to MQTT broker every 1s. After 30s of bootup will go to deep sleep. After 30 minutes will wake up and repeat the cycle. OLED/E-Paper variants also display gathered telemetry data. Calculated power demand is around 1mAh and can be lowered by reducing time spend awaken and removing LEDs from ESP module. Also higher resistor value for voltage divider could be used. Configuration of the station is done via MQTT messages. E.g. to set a name for device \u0026quot;18:FE:34:A7:05:1A\u0026quot; one should publish a string e.g. \u0026quot;Balkony\u0026quot; to \u0026quot;18:FE:34:A7:05:1A/name\u0026quot;. E-Paper variant is a little bit different. You can specify up to three other station names to display by separating names with a space, e.g. \u0026quot;paper room Balkony closet\u0026quot; to \u0026quot;18:FE:34:A7:05:1A/name\u0026quot;.\nHeadless DHT-11 and BMP280 modules can be seen in the photo, as well as Li-Ion battery and ESP-1 module. I had to solder wires directly GPIO16 and ADC of the ESP chip. It's not that hard as it looks, all that is needed - a little bit of flux, steady hands and thin soldering iron :) By the way, since there are very little GPIO pins available, I use RX/TX pins for I2C interface. I2C devices seem not to mind an initial burst of bootup information. I never changed the pins for ESPWeather variants that use ESP12 modules.\nOLED After some time I grew tired of checking up my phone for MQTT readings just to check what is going on at my desk, so I've built an OLED variant. Since I already have I2C interface for BMP280 sensor, all I did was hook up an OLED screen to SDA/SCL and thus OLED variant was born. Also I had to add some code to support that, of course, and since I had plans for other display types support in the future, I've created a neat C++ interface to easily swap display types during compile time.\nE-Paper As I was starting to accumulate a number of weather stations put in different places and I found smartphone MQTT client app invonvenient, I decided to use one of my Waveshare 2.13\u0026quot; E-Paper displays. I figured since it is ultra low power the whole station should last a very long time between charges. The display width allows to display data gathered from four stations. For this particular station I had to use ESP-12 module instead of ESP-1 as the latter lacks adequate number of GPIO pins :) This station does the following - connects to the MQTT broker, subscribes to station announcements channel and catches messages from preconfigured station names and displays them after all the readings are gathered. Just before going to deep sleep.\nConstruction DHT11 and BMP280 modules are used in this station for prototypes. BME280 or even BME680 will be used in production. SSD1306 and 3 colour 2.13\u0026quot; E-Paper HAT are used for OLED and E-Paper variants respectively. For E-Paper prototype Wemos D1 mini was used and later replaced with standalone ESP-12F module. For battery management I used a TP4050 micro-usb module with protection circuitry. If one has Lipo/LiIon batteries with protection in possession, then protection-less charging boards can be used.\nI plan adding a 6V solar panel so I could start measuring outside temperature without worrying about the battery. OLED variant in the above picture does not use any charging circuitry as it is meant for always-connected (or battery-pack) usage. However please note, that most battery packs will disconnect the battery from the station once it goes into deep sleep mode due to extremely low current consumption. Cases for these can be 3D printed.\nRx is SCL Tx is SDA GPIO 2 is 1-Wire interface for DHT11 GPIO 13, 14, 15, 5, 12, 4 are for EPD signals: DIN, CLK, CS, DC, RST, BUSY respectively TOUT or ADC is for battery monitoring and connected to battery input via 1/10 voltage divider (ADC can measure up to 1.0V, so this scale factor is quite convenient) sourced on Ebay: DHT11 for ESP-1S module, BMP280 board, TP4050 lipo micro-usb charger board, SSD1306 and 2.13\u0026quot; RPI-Zero E-Paper HAT (Waveshare) LiIon Batteries from various dead cell phones and cheap Chinese video registrators Cloning Since I use git submodules (for EasyOTA), cloning must be done using --recurse-submodules option:\n1git clone --recurse-submodules https://github.com/itohio/ESPWeather.git 2git checkout 10a7188545d1faf004c2990fb229bb47a6dc7dfc Configuration Please look at sample_wificonfig.h file, select relevant features, add default Wifi credentials, MQTT connection details and build after selecting appropriate board. Note, that wifi connection and MQTT are required if one wants to configure the station, e.g. changing the name or adding more access points.\nBuilding PlatformIO is used for this project. Just clone the project, import it into platformio, select board info and build. Flashing is also done this way. platformio.ini file contains some example upload_port values for OTA flashing. One can always use hostnames instead of ips. It's just that my bonjour service is confused because of different stations occupying the same hostname.\nBattery monitoring I use 100k trim pot directly across battery connector to the DH11 board, trim it to 1/10th of the battery voltage and solder the center tap to a TOUT pin right to the ESP8266 chip. I suggest flashing the ESP-1 module before soldering, so that the wire wouldn't be stressed to much. Discrete resistors for voltage divider can be seen in some the photos - this is because I ran out of trim pots:) And the dividing factor is not really precise, since I did not have 90k resistors and opted out for 2x51k + 10kx1k resistors. For the prototypes I am only interested in monitoring approximate voltage drop for the batteries and approximate point when DHT11 fails to provide meaningful readings. At about 2.80V of battery voltage DHT11 library returns nan. This voltage is even too low for ESP, but surprisingly it survives until 2.65(minus voltage drop across ldo).\nDeep Sleep function For waking up from Deep sleep GPIO 16 must be connected to RST. So more fine soldering skills are required in case of ESP-1. ESP-12 is more forgiving in that regard.\nReducing current consumption I've measured 1.8ma current in deep sleep. That means that the station sleeps for 30 minutes with 1.8mA current consuming 1.8mAh(I assume it never goes away). During all the communication and measurements somewhere around 70-90 mA are flowing to the ESP. So let's say it's 75mA for 30s. That translates to 0.625mAh. Therefore 800mAh battery would last a long time (about 13 days). Sadly, the batteries I am using in the photos are pretty much dead and charge up to around 75-120mAh. Which lasted for about 40 hours which confirms current consumption measurements and rough calculations to a degree. That was with two LEDs being constantly lit and an onboard regulator. Which I am surprised by, by the way. One can always remove those buggers, but I figured that with solar panel the station would run almost indefinitely and would have plenty of run time for home usage with a 800mAh battery. By removing the blue LED current drops to ~400uA during deep sleep and the dead'est battery still runs for 4 days already at 3.75V.\nTopics being published by the station announce Station will publish it's name to this topic once it connects to MQTT broker. Initially it will be a MAC address of the ESP. One can configure a different name by publishing to {station name}/name a new name which will be saved on the station.\n{station name}/temperature Temperature of the surroundings in deg. centigrade.\n{station name}/pressure Air pressure of the surroundings in milli Bar.\n{station name}/humidity Air relative humidity in percentage.\n{station name}/battery Battery voltage in volts.\nTopics being subscribed by the station {station name}/name Publishing to this topic will change station name. Station name must not contain neither commas nor spaces as these symbols are reserved for E-Paper variant. One can specify a list of station names separated by a space or comma, so that measurement from those stations can be monitored. E.g. \u0026quot;paper OLED outside mobile\u0026quot; was used in the E-Paper variant shown in the photo. That means, that E-Paper variant's name was set to \u0026quot;paper\u0026quot; and three other stations were monitored: OLED, outside and mobile. Since each station published persistent telemetry messages, the latest data is being monitored and subsequently displayed on the E-Paper display.\n{station name}/apadd Publishing to this topic will add another Wifi Network. One must supply a space delimited ssid and password, e.g. ssid password. This will be saved to the station and it will try to connect to this and other saved APs on boot.\n{station name}/apremove Publishing to this topic will remove the ap. One must publish ssid of the network that one wishes to remove.\n{station name} This topic accepts following publishes:\nSLEEP Forces the station to sleep for preset time (around 30 minutes).\nNOSLEEP Disables sleeping of the stations. This does not percist after restart. Useful for OTA development/etc.\nRESTART Forces restart of the station.\nPING Forces to announce it's name on announce topic. Useful for station status monitoring.\nThings to note RX/TX pins Due to pin count limitation on ESP-1 RX and TX pins are used for I2C bus. I2C stations seem to survive initial burst of boot info that is fed during bootup, but programming via serial while these pins are still connected to OLED/BMP280 is not advised. I've tried it, but ESP-12 module does not boot.\nSPIFFS Until now (20180216) ESP-01 with PUYA flash chips are not supported by the SPIFFS library (it can read uploaded, but not properly write files.). As a workaround one can publish config topics with persistent messages. E.g. setting name of the station. Setting up Wifi in this fashion isn't really useful for obvious reasons though.\nBMP280 For some reason very first measurement is way too high (both temperature and pressure). I've tried several libraries with no luck. In fact Adafruit_BMP280 library gives way too high readings all the time. The one I'm using currently (BMP280) is simplistic and allows to set different oversampling values and gives the most accurate readings except for the very first. To remediate that I skip several first readings.\nDHT11 Sometimes DHT11 will not read any data. And most of the time when the battery is almost depleted (\u0026lt;2.8V) there are no readings.\n","link":"https://itohi.com/blog/building-esp8266-weather-station-part-i/","section":"blog","tags":["arduino","esp8266","IoT","Sensors"],"title":"Building ESP8266 Weather station with BME280 (part 1)"},{"body":"I was always fascinated with balancing robots and wanted to build one myself. Some time ago I started collecting IMU, arduino boards, wheels, motors for other wheeled robots and one day decided to build a balancing robot instead. I've used wheels from old four wheel drive robot that used mouse sensors for odometry and was driven by an Arduino Pro mini. That robot never went alive anyway :)\nOriginally the robot was built using Arduino pro mini and all it could do was balance. I was thinking to add BT module to control it until I discovered that I have ESP8266 lying around. Also I decided to use a better IMU algorithm instead of DPU of the MPU6050. Thus the ESPBalancingRobot was born. It does use DC motors to balance and no encoders. Speed is being estimated using PWM signal averaging and constant angle is maintained using a double stage PID controller.\nThe source code for the robot can be found on GitHub.\nConfiguration before Building Before building and uploading please create wificonfig.h file with the following contents:\n1#define WIFI_SSID \u0026#34;ssid\u0026#34; 2#define WIFI_PASSWORD \u0026#34;password\u0026#34; 3#define ARDUINO_HOSTNAME \u0026#34;hostname\u0026#34; If you fork the repo, you can still have this file as it is in .gitignore and won't be added during commit.\nBuilding and flashing PlatformIO was used to develop the code, therefore the structure of the project conforms to what PlatformIO expects. Flash the ESP module first before soldering anything. Also upload SPIFFS. After that it is possible to use OTA, just don't forget to configure ESP to connect to your local network. You can start assembling the robot.\nConstruction Wheel base Wheel base consists of two geared motors, some scrap wheels and a 3D printed motor holder which is basically a tube with slots to hold wooden sheet. Later I added pads so that the robot wouldn't suffer much after falling over.\nMotor controller I used a 1A motor controller based on L293, however chinese manufacturers seemed to be too secretive about the chip used... Even though they advertise it as L293 motor controller board on ebay :)\nElectronics The robot is powered by two LiIon batteries salvages from old laptop battery. There is a dc-dc buck converter that supplies 3.3V for electronics, some random power switch, ESP-1 module and an MPU6050 board. Also some pullups, capacitors and a trim potentiometer for battery monitoring (turned down to 1:10 ratio).\nIMU was used a simple MPU6050 and can be seen under the ESP module. It is glued by hot glue to the battery holder. Alignment is not perfect, but staged PID adjusts for that.\nThe ESP-1 module For robot control we need six pins(not counting ADC pin for battery monitoring): 2x for I2C, 4x for PWM control. As ESP-1 module clearly doesn't have enough pins we need to add those. With a steady hand, small soldering iron, some flux and good eyes it is possible to solder those additional ports directly to the ESP chip pins.\nI used RX/TX pins for I2C as the chip emits some noise on those pins while booting and MPU doesn't seem to be upset about that. Although the motors might be.\nAlso I had to add pullUP resistors to GPIO0 and GPIO2 and a beafy capacitor on the 3.3V rail.\nOne thing to mention about the motors. For some reason one of my motor drivers and ESP modules during the early stages of the build just died on me. I figured that it had something to do with cheap motor driver burnup. So this time I added 1k resistors in series just to be safe.\nTheory of operation Mostly inspired by 5pqri1 EspWay balancing robot.\nPID tuning It is possible to tune PID controllers by building the firmware with\n1#define USE_LOGGING 1 somewhere in the beginning of the code. The UI changes somewhat and allows to see the realtime graphs of speed/angle values and also provides some sliders to set pid values. There are some issues, though with the ESPUI, as if I add all the controllers (for both PIDs), the ESP crashes. Also adding all the desired controls consumes to much flash size so the OTA doesn't allow to flash due to size limitations.\n","link":"https://itohi.com/blog/building-esp-1-balancing-robot/","section":"blog","tags":["arduino","esp8266","PID","PID Control","Robots"],"title":"Building ESP-1 balancing robot"},{"body":"","link":"https://itohi.com/tags/differential-drive/","section":"tags","tags":null,"title":"Differential Drive"},{"body":" As I've mentioned in the last blog post, I was trying to build a four wheel drive robot using arduino that utilizes two A3080 mouse sensors for odometry. Sadly that project never got finished and I disassembled the robot and built a balancing robot instead. However later I decided to not abandon the four wheel drive robot and ordered several ADNS3080 sensors with proper optics, obtained an electric wheelie toy, which lead to the birth of this WiFi controlled toy car.\nThe source code for this project can be found here.\nHow it works Chinese HBridge driver and ADNS3080 mouse sensor module are connected to Wemos D1 mini which serves a simple web page that allows to control the robot using touch gestures. Image retrieved using ADNS3080 is transferred to the web page using WebSockets as well as commands sent to the robot.\nThe robot is powered using two LiPo 1200mAh batteries forming a 2S1P battery. A potentiometer connected to GND and Battery Plus scales battery voltage which is fed to Analog pin of the Wemos board and subsequently is displayed on the web page.\nMechanically the robot consists of four wheels with each sides spinning independently. Interestingly enough, this toy has two wheels of the same side connected to one motor. So that all two pairs of wheels rotate independently like in a tank.\nAfter finishing this project I decided to refactor differential drive and ADNS3080 sensor code into a separate library, that I call EasyLocomotion. This little library has different driving algorithms for wheeled as well as legged robots and is still in development.\n","link":"https://itohi.com/blog/esp8266-wheelie/","section":"blog","tags":["arduino","esp8266","Differential Drive","Robots"],"title":"ESP8266 Wheelie"},{"body":"","link":"https://itohi.com/tags/pid/","section":"tags","tags":null,"title":"PID"},{"body":"","link":"https://itohi.com/tags/pid-control/","section":"tags","tags":null,"title":"PID Control"},{"body":"","link":"https://itohi.com/categories/robots/","section":"categories","tags":null,"title":"robots"},{"body":"","link":"https://itohi.com/tags/robots/","section":"tags","tags":null,"title":"Robots"},{"body":"","link":"https://itohi.com/series/","section":"series","tags":null,"title":"Series"}]